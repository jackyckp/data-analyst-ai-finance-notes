The moving average crossover strategy in moving_average_crossover_simple.py is a trend-following strategy that generates trading signals based on the relationship between two moving averages of different lengths.

### High-Level Concept

The core idea is that when a shorter-term moving average crosses above a longer-term moving average, it signals upward momentum and a potential buy signal. Conversely, when the shorter-term moving average crosses below the longer-term moving average, it signals downward momentum and a potential sell signal.

### How It Works in the Script

1.  **Calculate Moving Averages:** The script calculates two Simple Moving Averages (SMAs) for the 'Adj Close' price:
    *   A "fast" (shorter-term) SMA using a window defined by the `fast_MA` variable.
    *   A "slow" (longer-term) SMA using a window defined by the `slow_MA` variable.

    ```python
    # filepath: c:\Users\hklov\OneDrive\Documentos\UToronto\aps1052\HomeworkPandasExercise_UPLOAD\moving_average_crossover_simple.py
    # ...existing code...
    dfP['SMA_fast'] = dfP['Adj Close'].rolling(window=fast_MA).mean()
    dfP['SMA_slow'] = dfP['Adj Close'].rolling(window=slow_MA).mean()
    # ...existing code...
    ```

2.  **Generate Trading Signals:** Boolean columns are created to identify crossover points:
    *   `long_entry`: True when the fast SMA is greater than the slow SMA.
    *   `long_exit`: True when the fast SMA is less than the slow SMA.
    *   `short_entry`: True when the fast SMA is less than the slow SMA (if `shorts` is enabled).
    *   `short_exit`: True when the fast SMA is greater than the slow SMA (if `shorts` is enabled).

    ```python
    # filepath: c:\Users\hklov\OneDrive\Documentos\UToronto\aps1052\HomeworkPandasExercise_UPLOAD\moving_average_crossover_simple.py
    # ...existing code...
    # set up num_units_long
    dfP['long_entry'] = ((dfP.SMA_fast > dfP.SMA_slow))
    dfP['long_exit'] = ((dfP.SMA_fast < dfP.SMA_slow))
    # ...existing code...
    # set up num units short
    dfP['short_entry'] = ((dfP.SMA_fast < dfP.SMA_slow))
    dfP['short_exit'] = ((dfP.SMA_fast > dfP.SMA_slow))
    # ...existing code...
    ```

3.  **Determine Position (`stance`):** The `long_entry`, `long_exit`, `short_entry`, and `short_exit` signals are used to determine the trading position (`num_units_long` and `num_units_short`). These columns are filled forward (`fillna(method='pad')`) to maintain the position until an exit signal occurs. The final `stance` column represents the overall position (e.g., 1 for long, -1 for short, 0 for flat).

    ```python
    # filepath: c:\Users\hklov\OneDrive\Documentos\UToronto\aps1052\HomeworkPandasExercise_UPLOAD\moving_average_crossover_simple.py
    # ...existing code...
    dfP.loc[dfP['long_entry'], 'num_units_long'] = 1
    dfP.loc[dfP['long_exit'], 'num_units_long'] = 0
    # ... (similar logic for short) ...
    dfP['num_units_long'] = dfP['num_units_long'].fillna(method='pad')
    # ... (similar logic for short) ...
    dfP['stance'] = dfP['num_units_long'] * \
        (1-tcost) + dfP['num_units_short']*shorts*(1-tcost)
    # ...existing code...
    ```

4.  **Calculate System Returns:** The `stance` column (representing the trading position) is multiplied by the daily percentage returns (`pct_rets`) of the asset, shifted by a `delay` period, to calculate the system's daily returns (`syst_rets`).

    ```python
    # filepath: c:\Users\hklov\OneDrive\Documentos\UToronto\aps1052\HomeworkPandasExercise_UPLOAD\moving_average_crossover_simple.py
    # ...existing code...
    dfP['pct_rets'] = (dfP['Adj Close']-dfP['Adj Close'].shift(1)
                       )/dfP['Adj Close'].shift(1)
    dfP['syst_rets'] = dfP['pct_rets'] * dfP['stance'].shift(delay)
    # ...existing code...
    ```

### In Summary

The script calculates two moving averages, uses their crossover points to define entry and exit signals for long and short positions, translates these signals into a trading `stance`, and finally calculates the returns generated by following this `stance` based on the asset's price movements.

This strategy is simple but can suffer from lag (signals appear after a trend is established) and whipsaws (false signals in choppy markets).

------

**TotalAnnReturn in percent** is the **total annualized return** of your trading strategy, expressed as a percentage.

In your code:
````python
TotalAnnReturn = (end_val-start_val)/start_val/(days/periods)
print ("TotalAnnReturn in percent = %f" %(TotalAnnReturn*100))
````

- `end_val` = final value of your cumulative returns
- `start_val` = initial value (usually 1)
- `days` = total number of days in your backtest
- `periods` = number of days in a year (360 in your code)

**What does it mean?**  
It tells you the average return your strategy would have made per year, if the total return was spread evenly across each year (not compounded). It’s a simple annualized return, not accounting for compounding.

**Example:**  
If your strategy turned $1 into $1.50 over 3 years, TotalAnnReturn in percent would show the average percent gain per year, not accounting for compounding.

**CAGR** stands for **Compound Annual Growth Rate**. It measures the mean annual growth rate of an investment over a specified period of time, assuming the profits are reinvested at the end of each period.

In your code, `CAGR` is calculated as:

````python
CAGR = ((((end_val/start_val)**(1/years)))-1)
print ("CAGR in percent = %f" %(CAGR*100))
````

- `end_val` is the final value of your cumulative returns.
- `start_val` is the initial value (usually 1).
- `years` is the total number of years in your backtest.

**CAGR in percent** tells you the average annual return your strategy would have produced if the returns had been smoothed out evenly over the period. For example, a CAGR of 8% means your investment would have grown by 8% per year, compounded, over the test period.

Certainly! Lines 86 to 94 of moving_average_crossover_simple.py calculate the **Sharpe ratio**, a popular metric for evaluating the risk-adjusted return of a trading strategy.

Here’s the relevant code:

````python
try:
    sharpe =  (dfP['syst_rets'].mean()/dfP['syst_rets'].std()) * \
        np.sqrt(periods) # Sharpe ratio calculation
except ZeroDivisionError:
    sharpe = 0.0
````

### How does the Sharpe ratio work?

- **Sharpe Ratio** = (Mean strategy return) / (Standard deviation of strategy return) × sqrt(periods)
    - `dfP['syst_rets'].mean()` is the average daily return of your strategy.
    - `dfP['syst_rets'].std()` is the standard deviation (volatility) of those returns.
    - `np.sqrt(periods)` annualizes the ratio (since your returns are daily, multiplying by sqrt(360) gives an annualized Sharpe ratio).

### What does it mean?

- The Sharpe ratio tells you **how much excess return you get per unit of risk**.
- **Higher is better**: A Sharpe ratio above 1 is considered good, above 2 is very good.
- If the denominator is zero (no volatility), the code avoids division by zero by setting Sharpe to 0.

### Why use it?

- It helps compare strategies by showing which one gives more return for each unit of risk taken.
- It’s widely used in finance for portfolio and strategy evaluation.

**Summary:**  
The code block computes the Sharpe ratio to measure how efficiently your strategy converts risk into return.

------

Certainly! Lines 86 to 100 of moving_average_crossover_simple.py calculate and print the **Profit Factor** of your trading strategy. Here’s a breakdown:

````python
dfP['profits'] = np.where((dfP['syst_rets'] >= 0), dfP['syst_rets'], 0)
dfP['losses'] = np.where((dfP['syst_rets'] < 0), dfP['syst_rets'], 0)
profit_ratio = dfP['profits'].sum()/np.sum(np.abs(dfP['losses']))
print ("Profit Factor (should be above 1.3) = %f" %(round(profit_ratio,2)))
````

### What does this do?

- **dfP['profits']**: For each day, if the system return (`syst_rets`) is positive or zero, it keeps the value; otherwise, it sets it to 0. This column sums up all the gains.
- **dfP['losses']**: For each day, if the system return is negative, it keeps the value; otherwise, it sets it to 0. This column sums up all the losses (as negative numbers).
- **profit_ratio**: The sum of all profits is divided by the sum of the absolute value of all losses. This gives the **Profit Factor**.

### Why is this useful?

- **Profit Factor** = (Total Profits) / (Total Losses)
- A value **above 1** means the system is profitable overall.
- **Timothy Masters** prefers this because it directly compares gains to losses, making it easy to interpret: a Profit Factor of 1.5 means you make $1.50 for every $1 lost.

### Example

If your system made $300 in profits and lost $200, the Profit Factor is 1.5.

### In summary

This code block is a simple, robust way to measure how much your system wins for every dollar it loses—a key metric for system selection.

------
